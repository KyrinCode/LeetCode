### 22. Generate Parentheses

https://leetcode.cn/problems/generate-parentheses/

Medium # 2023/10/26

```go
func generateParenthesis(n int) []string {
    res := []string{}    
    dfs(&res, n, 0, 0, "")
    return res
}

func dfs(res *[]string, n, leftCnt, rightCnt int, str string) {
    if leftCnt > n {
        return
    } else if rightCnt > leftCnt {
        return
    } else if leftCnt == n && rightCnt == n {
        *res = append(*res, str)
    } else {
        dfs(res, n, leftCnt+1, rightCnt, str+"(")
        dfs(res, n, leftCnt, rightCnt+1, str+")")
    }
}
```

```go
func generateParenthesis(n int) []string {
    res := []string{}
    var dfs func(leftCnt, rightCnt int, str string)
    dfs = func(leftCnt, rightCnt int, str string) {
        if leftCnt > n {
            return
        } else if rightCnt > leftCnt {
            return
        } else if leftCnt == n && rightCnt == n {
            res = append(res, str)
        } else {
            dfs(leftCnt+1, rightCnt, str+"(")
            dfs(leftCnt, rightCnt+1, str+")")
        }
    }
    dfs(0, 0, "")
    return res
}
```

### 78. Subsets

https://leetcode.cn/problems/subsets/

Medium # 2023/10/26

```go
func subsets(nums []int) [][]int {
    res := [][]int{}
    path := []int{}
    var backtrack func(int)
    backtrack = func(pos int) {
        // åˆ¤æ–­æ›´æ–°ç­”æ¡ˆ
        res = append(res, append([]int{}, path...))
        // åˆ¤æ–­ç»“æŸæ¡ä»¶
        if pos == len(nums) {
            return
        }
        for p := pos; p < len(nums); p++ {
            // ï¼ˆåˆ¤æ–­é€‰æ‹©ï¼‰
            // è·¯å¾„ push pop
            path = append(path, nums[p])
            backtrack(p+1)
            path = path[:len(path)-1]
        }
        
    }
    backtrack(0)
    return res
}
```

### 2048. Next Greater Numerically Balanced Number

https://leetcode.cn/problems/next-greater-numerically-balanced-number/

Medium # 2023/12/09

```go
func nextBeautifulNumber(n int) int {
    nums := [][]int{
        {1},
        {2, 2},
        {1, 2, 2},
        {3, 3, 3},
        {1, 3, 3, 3},
        {4, 4, 4, 4},
        {1, 4, 4, 4, 4},
        {2, 2, 3, 3, 3},
        {5, 5, 5, 5, 5},
        {1, 2, 2, 3, 3, 3},
        {1, 5, 5, 5, 5, 5},
        {2, 2, 4, 4, 4, 4},
        {6, 6, 6, 6, 6, 6},
        {1, 2, 2, 4, 4, 4, 4},
    }
    permutations := make(map[int]bool)

    path := 0
    visited := make([]bool, 7)

    var backtrack func(int)
    backtrack = func(r int) { // ä¿è¯è°ƒç”¨æ—¶!visited
        // åˆ¤æ–­æ›´æ–°ç­”æ¡ˆ
        // åˆ¤æ–­ç»“æŸæ¡ä»¶
        if int(math.Pow10(len(nums[r])-1)) <= path && path < int(math.Pow10(len(nums[r]))) {
            permutations[path] = true
            return
        }
        for j := 0; j < len(nums[r]); j++ {
            // åˆ¤æ–­é€‰æ‹©
            if !visited[j] {
                // é€‰æ‹©æ›´æ–°
                visited[j] = true
                // è·¯å¾„ push
                path = path * 10 + nums[r][j]
                backtrack(r)
                // è·¯å¾„ pop
                path /= 10
                // é€‰æ‹©å›æ»š
                visited[j] = false
            }
        }
    }
    for r := 0; r < len(nums); r++ {
        path = 0
        clear(visited)
        backtrack(r)
    }
    p := []int{}
    for key, _ := range permutations {
        p = append(p, key)
    }
    sort.Ints(p)
    idx := sort.SearchInts(p, n)
    if p[idx] == n {
        return p[idx+1]
    }
    return p[idx]
}
```

### 46. Permutations

https://leetcode.cn/problems/permutations/

Medium # 2023/12/09

```go
func permute(nums []int) [][]int {
    l := len(nums)
    res := [][]int{}
    visited := make([]bool, l)
    path := []int{}
    var backtrack func()
    backtrack = func() {
        // åˆ¤æ–­æ›´æ–°ç­”æ¡ˆ
        // åˆ¤æ–­ç»“æŸæ¡ä»¶
        if len(path) == l {
            res = append(res, append([]int{}, path...))
            return
        }
        for i := 0; i < l; i++ {
            // åˆ¤æ–­é€‰æ‹©
            if !visited[i] {
                visited[i] = true
                path = append(path, nums[i])
                backtrack()
                path = path[:len(path)-1]
                visited[i] = false
            }
        }
    }
    backtrack()
    return res
}
```

### 51. N-Queens

https://leetcode.cn/problems/n-queens/

Hard # 2023/12/11

```go
func solveNQueens(n int) [][]string {
    res := [][]string{}
    board := []string{} // path
    columns := make([]bool, n) // visited æ£€æŸ¥åˆ—
    queens := make([]int, n) // visited æ£€æŸ¥å¯¹è§’çº¿
    for i := 0; i < n; i++ {
        queens[i] = -1
    }

    isValid := func(row, col int) bool {
        r, c := row - 1, col - 1
        for r >= 0 && c >= 0 {
            if queens[r] == c {
                return false
            }
            r--
            c--
        }
        r, c = row - 1, col + 1
        for r >= 0 && c < n {
            if queens[r] == c {
                return false
            }
            r--
            c++
        }
        return true
    }

    var backtrack func(int)
    backtrack = func(row int) {
        // åˆ¤æ–­æ›´æ–°ç­”æ¡ˆ
        // åˆ¤æ–­ç»“æŸæ¡ä»¶
        if row == n {
            res = append(res, append([]string{}, board...))
            return
        }
        
        for col := 0; col < n; col++ {
            // åˆ¤æ–­é€‰æ‹©
            if !columns[col] && isValid(row, col) {
                columns[col] = true
                queens[row] = col
                s := ""
                for i := 0; i < n; i++ {
                    if i == col {
                        s += "Q"
                    } else {
                        s += "."
                    }
                }
                board = append(board, s)
                backtrack(row+1)
                board = board[:len(board)-1]
                queens[row] = -1
                columns[col] = false
            }
        }
    }
    backtrack(0)
    return res
}
```

### 77. Combinations

https://leetcode.cn/problems/combinations/

Medium # 2023/12/19

```go
func combine(n int, k int) [][]int {
    res := [][]int{}
    path := []int{}
    var backtrack func(int)
    backtrack = func(pos int) {
        // åˆ¤æ–­æ›´æ–°ç­”æ¡ˆ
        // åˆ¤æ–­ç»“æŸæ¡ä»¶
        if len(path) == k { // ç»„åˆä¸å­é›†åªæœ‰è¿™é‡Œä¸åŒ
            res = append(res, append([]int{}, path...))
            return
        }
        // åˆ¤æ–­é€‰æ‹©
        for i := pos; i < n; i++ {
            path = append(path, i+1)
            backtrack(i+1)
            path = path[:len(path)-1]
        }
    }
    backtrack(0)
    return res
}
```

### 90. Subsets II

https://leetcode.cn/problems/subsets-ii/

Medium # 2023/12/19

```go
func subsetsWithDup(nums []int) [][]int {
    l := len(nums)
    sort.Ints(nums) // å…ˆæ’åºè®©ç›¸ç­‰çš„æŒ¨åœ¨ä¸€èµ·
    res := [][]int{}
    path := []int{}
    var backtrack func(int)
    backtrack = func(pos int) {
        res = append(res, append([]int{}, path...))
        if pos == l {
            return
        }
        for i := pos; i < l; i++ {
        	// å¦‚æœä¸€ä¸ªèŠ‚ç‚¹æœ‰å¤šæ¡å€¼ç›¸åŒçš„æ ‘æç›¸é‚» åˆ™åªéå†ç¬¬ä¸€æ¡ å‰©ä¸‹çš„éƒ½å‰ªææ‰
            if i == pos || nums[i] != nums[i-1] {
                path = append(path, nums[i])
                backtrack(i+1)
                path = path[:len(path)-1]
            }
        }
    }
    backtrack(0)
    return res
}
```

### 40. Combination Sum II

https://leetcode.cn/problems/combination-sum-ii/

Medium # 2023/12/23

```go
func combinationSum2(candidates []int, target int) [][]int {
    sort.Ints(candidates)
    res := [][]int{}
    path := []int{}
    sum := 0
    var backtrack func(int)
    backtrack = func(pos int) {
        // åˆ¤æ–­ç­”æ¡ˆæ›´æ–°
        if sum == target {
            res = append(res, append([]int{}, path...))
        }
        // åˆ¤æ–­ç»“æŸæ¡ä»¶
        if sum > target || pos == len(candidates) {
            return
        }
        for i := pos; i < len(candidates); i++ {
            // åˆ¤æ–­é€‰æ‹©
            if i == pos || candidates[i] != candidates[i-1] {
                path = append(path, candidates[i])
                sum += candidates[i]
                backtrack(i+1)
                sum -= candidates[i]
                path = path[:len(path)-1]
            } 
        }
    }
    backtrack(0)
    return res
}
```

### 47. Permutations II

https://leetcode.cn/problems/permutations-ii/

Medium # 2023/12/23

```go
func permuteUnique(nums []int) [][]int {
    sort.Ints(nums)
    res := [][]int{}
    path := []int{}
    visited := make([]bool, len(nums))
    var backtrack func()
    backtrack = func() {
        // åˆ¤æ–­ç­”æ¡ˆæ›´æ–°
        // åˆ¤æ–­ç»“æŸæ¡ä»¶
        if len(path) == len(nums) {
            res = append(res, append([]int{}, path...))
        }
        for i := 0; i < len(nums); i++ {
            // åˆ¤æ–­é€‰æ‹©
            if !visited[i] && (i == 0 || nums[i] != nums[i-1] || visited[i-1]) { // å‰ªæ å¦‚æœä¸å‰ä¸€ä¸ªå€¼ç›¸ç­‰çš„è¯ åˆ™å¿…é¡»å‰ä¸€ä¸ªå·²ç»ç”¨äº†æ‰èƒ½ç”¨
                visited[i] = true
                path = append(path, nums[i])
                backtrack()
                path = path[:len(path)-1]
                visited[i] = false
            }
        }
    }
    backtrack()
    return res
}
```

### 39. Combination Sum

https://leetcode.cn/problems/combination-sum/

Medium # 2023/12/23

```go
func combinationSum(candidates []int, target int) [][]int {
    res := [][]int{}
    path := []int{}
    sum := 0
    var backtrack func(int)
    backtrack = func(pos int) {
        // åˆ¤æ–­ç­”æ¡ˆæ›´æ–°
        if sum == target {
            res = append(res, append([]int{}, path...))
        }
        // åˆ¤æ–­ç»“æŸæ¡ä»¶
        if sum > target || pos == len(candidates) {
            return
        }
        for i := pos; i < len(candidates); i++ {
            path = append(path, candidates[i])
            sum += candidates[i]
            backtrack(i)
            sum -= candidates[i]
            path = path[:len(path)-1]
        }
    }
    backtrack(0)
    return res
}
```

### 216. Combination Sum III

https://leetcode.cn/problems/combination-sum-iii/

Medium # 2023/12/24

```go
func combinationSum3(k int, n int) [][]int {
    res := [][]int{}
    path := []int{}
    sum := 0
    var backtrack func(int)
    backtrack = func(pos int) {
        // åˆ¤æ–­ç­”æ¡ˆæ›´æ–°
        if len(path) == k && sum == n {
            res = append(res, append([]int{}, path...))
        }
        // åˆ¤æ–­ç»“æŸæ¡ä»¶
        if len(path) >= k || sum >= n || pos == 10 {
            return
        }
        // åˆ¤æ–­é€‰æ‹©
        for i := pos; i < 10; i++ {
            path = append(path, i)
            sum += i
            backtrack(i+1)
            sum -= i
            path = path[:len(path)-1]
        }
    }
    backtrack(1)
    return res
}
```

### 2397. Maximum Rows Covered by Columns

https://leetcode.cn/problems/maximum-rows-covered-by-columns/

Medium # 2024/01/04

```go
func maximumRows(matrix [][]int, numSelect int) int {
    r, c := len(matrix), len(matrix[0])
    combination := [][]int{}
    path := []int{}
    var backtrack func(int)
    backtrack = func(pos int) {
        // åˆ¤æ–­æ›´æ–°ç­”æ¡ˆ
        // åˆ¤æ–­ç»“æŸæ¡ä»¶
        if len(path) == numSelect {
            combination = append(combination, append([]int{}, path...))
            return
        }
        for i := pos; i < c; i++ {
            // åˆ¤æ–­é€‰æ‹©
            path = append(path, i)
            backtrack(i+1)
            path = path[:len(path)-1]
        }
    }
    backtrack(0)
    tmp := make(map[int]bool)
    rest := r
    for _, com := range combination {
        clear(tmp)
        for j := 0; j < c; j++ {
            idx := sort.SearchInts(com, j)
            if idx == len(com) || com[idx] != j {
                for i := 0; i < r; i++ {
                    if matrix[i][j] == 1 {
                        tmp[i] = true
                    }
                }
            }
        }
        rest = min(rest, len(tmp))
    }
    return r - rest
}
```







600000000

é‡‘ 800

é“¶ 1200

æ°´æ™¶ 3000



ğŸš€ğŸš€ğŸš€ Exciting news for loyal Rosetta supporters! 

The \$rswl event was incredibly ğŸ”¥, with all tokens minted in just ONE block! ğŸ˜³ We deeply appreciate your participation â¤ï¸â¤ï¸â¤ï¸. With a strong commitment to the #Bitcoin ecosystem, a fair launch has always been the team's intention. Despite many of you were prevented from becoming $rswl holders, our developers have identified a total of 3167 failed inscribe-mint transactions. To express our sincerity, the team has decided on the following compensation:

All affected addresses will receive a Guaranteed Whitelist for \$rstt OG PASS and future Rosetta ecosystem development, with a quota tied to the $rswl minting fee! ğŸŒˆ

Check here to see if you are eligible for the Guaranteed Whitelist https://www.rosettaprotocol.com/compensate.

#Rosetta #BRC20

----thread----

Besides, early supporter activity has ended. Stay tuned for comprehensive details on the benefits for \$rswl holders, \$rswl participants and all early supporters, along with the exciting \$rstt OG PASS event. Coming soon! ğŸš€ ğŸª¨

å¯¹äºå¹¸è¿çš„$rswlçš„æŒå¸ç”¨æˆ·ï¼Œæˆ‘ä»¬å°†åœ¨OG PASS minting eventå¼€å§‹å‰çš„3å°æ—¶å†…éšæœºæ—¶é—´è¿›è¡Œå¿«ç…§ã€‚å¿«ç…§çš„åœ°å€åŒæ ·å°†è·å¾—Guaranteed Whitelistã€‚

Congratulations! You are one of the winners of Rosetta 10k Follower Givesway event! Pls drop your Taproot Bitcoin Address here. We will put you in the Guaranteed Whitelist for $rstt OG PASS event and future eco development.

